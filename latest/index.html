<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Compose.jl documentation</title><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script></head><body><nav class="toc"><h1>Compose.jl</h1><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"><li><a class="toctext" href="#Compose-is-declarative-1">Compose is declarative</a></li><li><a class="toctext" href="#Everything-is-a-tree-1">Everything is a tree</a></li><li><a class="toctext" href="#The-compose-function-accepts-S-expressions-1">The compose function accepts S-expressions</a></li><li><a class="toctext" href="#Trees-can-be-visualized-with-introspect-1">Trees can be visualized with introspect</a></li><li><a class="toctext" href="#Contexts-specify-a-coordinate-system-for-their-children-1">Contexts specify a coordinate system for their children</a></li><li><a class="toctext" href="#Measures-can-be-a-combination-of-absolute-and-relative-units-1">Measures can be a combination of absolute and relative units</a></li><li><a class="toctext" href="#Forms-and-Properties-can-be-vectorized-1">Forms and Properties can be vectorized</a></li><li><a class="toctext" href="#Compose-can-produce-arbitrary-directed-graphs-1">Compose can produce arbitrary directed graphs</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/Hydrotoast/Compose.jl/tree/ad8ea3379f87feb621e85d3e04a1771466ea5392/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><p><img src="assets/logo.svg" alt="Logo"/></p><p>Compose is a declarative vector graphics system written in Julia. It&#39;s designed to simplify the creation of complex graphics and serves as the basis of the <a href="https://github.com/dcjones/Gadfly.jl">Gadfly</a> data visualization package.</p><h2><a class="nav-anchor" id="Compose-is-declarative-1" href="#Compose-is-declarative-1">Compose is declarative</a></h2><p>In a declarative graphics system, a figure is built without specifying the precise sequence of drawing commands but by arranging shapes and attaching properties. This makes it easy to break a complex graphic into manageable parts and then figure out how to combine the parts.</p><h2><a class="nav-anchor" id="Everything-is-a-tree-1" href="#Everything-is-a-tree-1">Everything is a tree</a></h2><p>Graphics in Compose are defined using a tree structure. It&#39;s not unlike SVG in this regard, but has simpler semantics. There are three important types that make up the nodes of the tree:</p><ul><li><p><code>Context</code>: An internal node.</p></li><li><p><code>Form</code>: A leaf node that defines some geometry, like a line or a polygon.</p></li><li><p><code>Property</code>: A leaf node that modifies how its parent&#39;s subtree is drawn, like fill color, font family, or line width.</p></li></ul><p>The all-important function in Compose, is called, not surprisingly, <code>compose</code>. Calling <code>compose(a, b)</code> will return a new tree rooted at <code>a</code> and with <code>b</code> attached as a child.</p><p>That&#39;s enough to start drawing some simple shapes.</p><div></div><div><pre><code class="language-julia">using Compose

composition = compose(compose(context(), rectangle()), fill(&quot;tomato&quot;))
draw(SVG(&quot;tomato.svg&quot;, 4cm, 4cm), composition)</code></pre></div><p><img src="tomato.svg" alt/></p><h2><a class="nav-anchor" id="The-compose-function-accepts-S-expressions-1" href="#The-compose-function-accepts-S-expressions-1">The compose function accepts S-expressions</a></h2><p>In the first example, we had to call <code>compose</code> twice just to draw a lousy red square. Fortunately <code>compose</code> has a few tricks up its sleeve. As everyone from lisp hackers and <a href="http://en.wikipedia.org/wiki/Newick_format">phylogeneticists</a> knows, trees can be defined most tersely using S-expressions. We can rewrite our first example like:</p><pre><code class="language-julia"># equivalent to compose(compose(context(), rectangle()), fill(&quot;tomato&quot;)))
compose(context(), rectangle(), fill(&quot;tomato&quot;))</code></pre><p>Furthermore, more complex trees can be formed by grouping subtrees with parenthesis or brackets.</p><div><pre><code class="language-julia">composition = compose(context(),
        (context(), circle(), fill(&quot;bisque&quot;)),
        (context(), rectangle(), fill(&quot;tomato&quot;)))
draw(SVG(&quot;tomato_bisque.svg&quot;, 4cm, 4cm), composition)</code></pre></div><p><img src="tomato_bisque.svg" alt/></p><h2><a class="nav-anchor" id="Trees-can-be-visualized-with-introspect-1" href="#Trees-can-be-visualized-with-introspect-1">Trees can be visualized with introspect</a></h2><p>A useful function for visualizing the graphic that you&#39;ve constructed is <code>introspect</code>. It takes a <code>Context</code> defining a graphic and returns a new graphic with a schematic of the tree.</p><div><pre><code class="language-julia">tomato_bisque =
    compose(context(),
            (context(), circle(), fill(&quot;bisque&quot;)),
            (context(), rectangle(), fill(&quot;tomato&quot;)))

introspect(tomato_bisque)</code></pre><?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.2"
     width="60mm" height="60mm" viewBox="0 0 60 60"
     stroke="none"
     fill="#000000"
     stroke-width="0.3"
     font-size="3.88"
>
<g fill="#303030" id="img-b36915e4-1">
  <rect x="0" y="0" width="60" height="60"/>
</g>
<g stroke="#F4E6D6" id="img-b36915e4-2">
  <path fill="none" d="M22.5,30 L 52.5 50"/>
  <path fill="none" d="M22.5,30 L 37.5 50"/>
  <path fill="none" d="M7.5,30 L 22.5 50"/>
  <path fill="none" d="M7.5,30 L 7.5 50"/>
  <path fill="none" d="M7.5,10 L 22.5 30"/>
  <path fill="none" d="M7.5,10 L 7.5 30"/>
</g>
<g stroke-width="0.5" stroke="#303030" id="img-b36915e4-3">
  <g fill="#FF6B69" id="img-b36915e4-4">
    <path d="M49.5,47 L 55.5 47 52.5 53 z"/>
  </g>
  <g fill="#00C5C0" id="img-b36915e4-5">
    <rect x="34.5" y="47" width="6" height="6"/>
  </g>
  <g fill="#000000" id="img-b36915e4-6">
    <text x="37.5" y="50" text-anchor="middle" dy="0.35em">C</text>
  </g>
  <g fill="#FF6B69" id="img-b36915e4-7">
    <path d="M19.5,47 L 25.5 47 22.5 53 z"/>
  </g>
  <g fill="#00C5C0" id="img-b36915e4-8">
    <rect x="4.5" y="47" width="6" height="6"/>
  </g>
  <g fill="#000000" id="img-b36915e4-9">
    <text x="7.5" y="50" text-anchor="middle" dy="0.35em">R</text>
  </g>
  <g fill="#F4E6D6" id="img-b36915e4-10">
    <use xlink:href="#img-b36915e4-11" x="22.5" y="30"/>
  </g>
  <g fill="#F4E6D6" id="img-b36915e4-12">
    <use xlink:href="#img-b36915e4-13" x="7.5" y="30"/>
  </g>
  <g fill="#F4E6D6" id="img-b36915e4-14">
    <use xlink:href="#img-b36915e4-15" x="7.5" y="10"/>
  </g>
</g>
<defs>
  <g id="img-b36915e4-11">
    <circle cx="0" cy="0" r="3"/>
  </g>
  <g id="img-b36915e4-13">
    <circle cx="0" cy="0" r="3"/>
  </g>
  <g id="img-b36915e4-15">
    <circle cx="0" cy="0" r="3"/>
  </g>
</defs>
</svg>
</div><p>This is a little cryptic, but you can use this limited edition decoder ring:</p><pre><code class="language-julia">using Compose, Colors, Measures # hide
set_default_graphic_size(6cm, 4cm) # hide

figsize = 6mm
t = table(3, 2, 1:3, 2:2, y_prop=[1.0, 1.0, 1.0])
t[1,1] = [compose(context(minwidth=figsize + 2mm, minheight=figsize),
                  circle(0.5, 0.5, figsize/2), fill(LCHab(92, 10, 77)))]
t[2,1] = [compose(context(minwidth=figsize + 2mm, minheight=figsize),
                  rectangle(0.5cx - figsize/2, 0.5cy - figsize/2, figsize, figsize),
                  fill(LCHab(68, 74, 192)))]
t[3,1] = [compose(context(minwidth=figsize + 2mm, minheight=figsize),
                  polygon([(0.5cx - figsize/2, 0.5cy - figsize/2),
                           (0.5cx + figsize/2, 0.5cy - figsize/2),
                           (0.5, 0.5cy + figsize/2)]),
                  fill(LCHab(68, 74, 29)))]
t[1,2] = [compose(context(), text(0, 0.5, &quot;Context&quot;, hleft, vcenter))]
t[2,2] = [compose(context(), text(0, 0.5, &quot;Form&quot;, hleft, vcenter))]
t[3,2] = [compose(context(), text(0, 0.5, &quot;Property&quot;, hleft, vcenter))]
compose(context(), t, fill(LCHab(92, 10, 77)), fontsize(10pt))</code></pre><h2><a class="nav-anchor" id="Contexts-specify-a-coordinate-system-for-their-children-1" href="#Contexts-specify-a-coordinate-system-for-their-children-1">Contexts specify a coordinate system for their children</a></h2><p>In addition to forming internal nodes to group <code>Form</code> and <code>Property</code> children, a <code>Context</code> can define a coordinate system using the <code>context(x0, y0, width, height)</code> form. Here we&#39;ll reposition some circles by composing them with contexts using different coordinate systems.</p><div></div><div><pre><code class="language-julia">composition = compose(context(), fill(&quot;tomato&quot;),
        (context(0.0, 0.0, 0.5, 0.5), circle()),
        (context(0.5, 0.5, 0.5, 0.5), circle()))
draw(SVG(&quot;tomatos.svg&quot;, 4cm, 4cm), composition)</code></pre></div><p><img src="tomatos.svg" alt/></p><p>The context&#39;s box (i.e. <code>(x0, y0, width, height)</code>) is given in terms of its parent&#39;s coordinate system and defaults to <code>(0, 0, 1, 1)</code>. All the children of a context will use coordinates relative to that box.</p><p>This is an easy mechanism to translate the coordinates of a subtree in the graphic, but coordinates can be scaled and shifted as well by passing a <code>UnitBox</code> to the <code>units</code> attribute.</p><div><pre><code class="language-julia">composition = compose(context(),
        (context(units=UnitBox(0, 0, 1000, 1000)),
         polygon([(0, 1000), (500, 1000), (500, 0)]),
         fill(&quot;tomato&quot;)),
        (context(),
         polygon([(1, 1), (0.5, 1), (0.5, 0)]),
         fill(&quot;bisque&quot;)))
draw(SVG(&quot;tomato_bisque_triangle.svg&quot;, 4cm, 4cm), composition)</code></pre></div><p><img src="tomato_bisque_triangle.svg" alt/></p><h2><a class="nav-anchor" id="Measures-can-be-a-combination-of-absolute-and-relative-units-1" href="#Measures-can-be-a-combination-of-absolute-and-relative-units-1">Measures can be a combination of absolute and relative units</a></h2><p>Complex visualizations often are defined using a combination of relative and absolute units. Compose makes these easy. In fact there are three sorts of units used in Compose:</p><ul><li><p><strong>Context units</strong>: If no unit is explicitly attached to a number, it is assumed to be in “context units”, which are relative to the parent Context&#39;s box and coordinate system. (Constants: <code>cx</code>, <code>cy</code>)</p></li><li><p><strong>Width/Height units</strong>: Sometimes you&#39;ll want place geometry in relative coordinates, but bypassing the parent context&#39;s coordinate system. Width/height work so that <code>(0w, 0h)</code> is always the top-left corner of the contxt, and <code>(1w, 1h)</code> is always the bottom-right. (Constants: <code>w</code>, <code>h</code>)</p></li><li><p><strong>Absolute units</strong>: Absolute units are inches, centimeters, points, etc. (Constants: <code>inch</code>, <code>cm</code>, <code>mm</code>, <code>pt</code>)</p></li></ul><p>Any linear combination of these types of units is allowed. For example: <code>0.5w + 2cm - 5cx</code> is a valid measure that can be used anywhere.</p><h2><a class="nav-anchor" id="Forms-and-Properties-can-be-vectorized-1" href="#Forms-and-Properties-can-be-vectorized-1">Forms and Properties can be vectorized</a></h2><p>Often one needs to produce many copies of a similar shape. Most of the forms an properties have a scalar and vector forms to simplify this sort of mass production.</p><p>We&#39;ll use <code>circle</code> as an example, which has two constructors:</p><pre><code class="language-julia">circle(x=0.5w, y=0.5h, r=0.5w)
circle(xs::AbstractArray, ys::AbstractArray, rs::AbstractArray)</code></pre><p>The first of these creates only circle centered at <code>(x, y)</code> with radius <code>r</code>. The second form can succinctly create many circles (using the <a href="https://github.com/JuliaLang/Colors.jl">Colors</a> package to specify the <code>LHCab</code> colorspace):</p><div></div><div><pre><code class="language-julia">composition = compose(context(),
        circle([0.25, 0.5, 0.75], [0.25, 0.5, 0.75], [0.1, 0.1, 0.1]),
        fill(LCHab(92, 10, 77)))
draw(SVG(&quot;circles.svg&quot;, 4cm, 4cm), composition)</code></pre></div><p><img src="circles.svg" alt/></p><p>The arrays in passed to <code>xs</code>, <code>ys</code>, and <code>rs</code> need not be the same length. Shorter arrays will be cycled. This let&#39;s us shorten this last example by only specifying the radius just once.</p><div><pre><code class="language-julia">composition = compose(context(),
        circle([0.25, 0.5, 0.75], [0.25, 0.5, 0.75], [0.1]),
        fill(LCHab(92, 10, 77)))
draw(SVG(&quot;cycled_circles.svg&quot;, 4cm, 4cm), composition)</code></pre></div><p><img src="cycled_circles.svg" alt/></p><p>The <code>fill</code> is a property can also be vectorized here to quickly assign different colors to each circle.</p><div><pre><code class="language-julia">circles_fill_vectorized = compose(context(),
        circle([0.25, 0.5, 0.75], [0.25, 0.5, 0.75], [0.1]),
        fill([LCHab(92, 10, 77), LCHab(68, 74, 192), LCHab(78, 84, 29)]))
draw(SVG(&quot;circles_fill_vectorized.svg&quot;, 4cm, 4cm), circles_fill_vectorized)</code></pre></div><p><img src="circles_fill_vectorized.svg" alt/></p><p>If vector properties are used with vector forms, they must be of equal length.</p><h2><a class="nav-anchor" id="Compose-can-produce-arbitrary-directed-graphs-1" href="#Compose-can-produce-arbitrary-directed-graphs-1">Compose can produce arbitrary directed graphs</a></h2><p>Though we&#39;ve so far explained <code>compose</code> as producing trees, there&#39;s nothing stopping one from producing an arbitrary directed graph. This can be quite useful in some cases.</p><p>In this example, only one triangle object is ever initialized, despite many triangles being drawn, which is possible because the graph produced by <code>siepinski</code> is not a tree. The triangle polygon has many parent nodes than “re-contextualize” that triangle by repositioning it.</p><div><pre><code class="language-julia">function sierpinski(n)
    if n == 0
        compose(context(), polygon([(1,1), (0,1), (1/2, 0)]))
    else
        t = sierpinski(n - 1)
        compose(context(),
                (context(1/4,   0, 1/2, 1/2), t),
                (context(  0, 1/2, 1/2, 1/2), t),
                (context(1/2, 1/2, 1/2, 1/2), t))
    end
end

composition = compose(sierpinski(6), fill(LCHab(92, 10, 77)))
draw(SVG(&quot;sierpinski.svg&quot;, 8cm, 8*(sqrt(3)/2)*cm), composition)</code></pre></div><p><img src="sierpinski.svg" alt/></p><p>There are no safeguards to check for cycles. You can produce a graph with a cycle and Compose will run in an infinite loop trying to draw it. In most applications, this isn&#39;t a concern.</p><footer><hr/></footer></article></body></html>
